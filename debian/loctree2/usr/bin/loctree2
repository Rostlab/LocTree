#!/usr/bin/perl
use strict;
use warnings;
use feature qw(say);
use Carp qw| cluck :DEFAULT |; #display the subroutines as they are approached
use Config::IniFiles;
use File::Copy;
use diagnostics;
use File::Spec;
use File::Basename;
use File::Temp qw/ tempfile tempdir /;
use Cwd 'abs_path';
use Cwd qw(realpath);
use File::Path qw(make_path remove_tree);
use Getopt::Long;

# SYSTEM CONFIGURATION RETRIEVAL
our $config;
BEGIN {
    our $VERSION = "1.0.9";
    delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};
#    $ENV{PATH} = "/bin:/usr/bin";
    my ( $defaultconfig, $etcconfig );
    if( -e "/usr/share/loctree2/loctree2rc.default" ) { $defaultconfig = Config::IniFiles->new( -file => "/usr/share/loctree2/loctree2rc.default" ); }
    if( -e "/etc/loctree2rc" ) { $etcconfig = Config::IniFiles->new( -file => "/etc/loctree2rc", -import => $defaultconfig ); } else { $etcconfig = $defaultconfig; }
    if( ( $ENV{LOCTREE2CONF} && -e "$ENV{LOCTREE2CONF}" ) || -e "$ENV{HOME}/.loctree2rc" ) { $config = Config::IniFiles->new( -file => $ENV{LOCTREE2CONF} || "$ENV{HOME}/.loctree2rc", -import => $etcconfig ); } else { $config = $etcconfig; }
}

# popularity contest
if( system('pp_popcon_cnt', '-p', 'loctree2') == -1 ){ warn("The Rost Lab recommends you install the pp-popularity-contest package that provides pp_popcon_cnt:\n\nsudo apt-get install pp-popularity-contest\n"); }

###########################################
############# process input ###############

my($inputDirPath,$outputFilePathRef,$domain,$tmpDirPath,$fastaFile,$blastMat);
my $debug=0;
my $quiet=0;

my $args_ok=GetOptions( 'indir=s'          =>  \$inputDirPath,
                        'resfile=s'         =>  \$outputFilePathRef,
                        'domain=s'      =>  \$domain,
                        'tmpdir=s'      =>  \$tmpDirPath,
        #                'nrfiles=s'     => \$nrFiles,
                        'fasta=s'       => \$fastaFile,
                        'blastmat=s'      => \$blastMat,
                        'printdebug+'   => \$debug,
                        'quiet+'        => \$quiet
);

my $outputFilePath = $outputFilePathRef;

#####
sub die_usage{
    my $msg=shift;
	eval{
    say "\nDESCRIPTION:\nProtein sub-cellular localization prediction for proteins in all domains of life";
	say "\nUSAGE:\nloctree2 -i <input directory> -r <result file> -d <domain> [OPTIONS]";
    say "or";
    say "loctree2 -f <fasta file> -b <psi-blast profile file> -r <result file> -d <domain>";
	say "\nMANDATORY:";
	say "-i, --indir <directory>\n\tInput directory with one [.fasta|.fa|.f] file and one [.profile|.blast|.psiBlast|.blastPsiMat] file for each sequence to be predicted. A .fasta file must contain exactly ONE protein sequence. Corresponding fasta and profile files must have the same prefix (i.e. if there is a file \"example.fasta\", there must also be a file \"example.profile). Or use --fasta and --blastmat";
    say "\n-f, --fasta <file>\n\tFile containing exactly one fasta input sequence. This parameter must be used in combination with --blastmat";
    say "\n-b --blastmat <file>\n\tFile containing exactly one evolutionary profile. This parameter must be used in combination with --fasta";
	say "\n-r, --resfile <file>\n\tOutput result file in which each line contains the name of the sequence, the predicted sub-cellular localization and the reliability of the prediction";
    say "\n-d, --domain\n\tThe domain of the organism of the protein sequences to be predicted\n\tOptions:\n\t'arch' for Archaea\n\t'bact' for Bacteria\n\t'euka' for Eukaryota";
	say "\nOPTIONS:";
   # say "\n-n, --nrfiles\n\tNumber of protein sequences processed per run. If the number of fasta files in <input directory> exceeds this threshold then the output for the next nrfiles sequences will be written to <output_file>_2. This will be repeated until all sequences in <input directory> are read in";
    say "\n-p, --printdebug\n\tPrint debugging messages";
    say "\n-q, --quiet\n\tSilence progress messages";
    say "\n-t, --tmpdir <directory>\n\tWorking directory. Intermediate files will be saved here. If not given, a temporary directory is used. The temporary directory is automatically removed at the end of a run when debugging is off";
    }; warn "\n$msg\n";
    exit(1);
}
###
if(!$fastaFile){
    if(! -d $inputDirPath)
    {
        die_usage("\nError: input directory $inputDirPath does not exist\n");
    }
}

if(!$inputDirPath)
{
    if(!$fastaFile)
    {
        die_usage("\nError: no input directory or input fasta file defined\n");
    }
    if(!-e $fastaFile)
    {
        die_usage("\nError: input fasta file $fastaFile does not exist\n");
    }
    if(!-e $blastMat)
    {
        die_usage("\nError: input profile file $blastMat does not exist\n");
    }
}
if($inputDirPath && $fastaFile)
{
    die_usage("\nError: please define either a directory containing both fasta and profile files or one fasta and one profile file\n");
}
if($fastaFile && !$blastMat)
{
    die_usage("\nError: no profile file defined\n");
}
if($blastMat && !$fastaFile)
{
    die_usage("\nError: no input fasta file defined\n");
}
die_usage("\nError: no output file defined\n") unless $outputFilePathRef;
die_usage("\nError: no domain defined\n") unless $domain;
die_usage("\nError: unknown argument\n") unless $args_ok;


# specify the working directories
our $baseDir = glob($config->val('loctree2', 'basedir'));
our $dataDir = glob($config->val('loctree2', 'datadir'));

# lkajan: call script to handle the large package data
{
    my @cmd = ("$baseDir/loctree2data", '--datadir', $dataDir, '--data-version', '1.0.2', $debug ? ( '--debug' ) : () ); my $ret = system(@cmd);
    if( $ret == -1 ){ confess("Failed to call @cmd: ".($?>>8)); }elsif( $ret != 0 ){ exit(1); }
}

if ($tmpDirPath){
    $tmpDirPath=Cwd::realpath( $tmpDirPath );
}
else {
    $tmpDirPath=tempdir( "loctree2tmpXXXXXXXXXX", DIR => File::Spec->tmpdir(), CLEANUP => !$debug);
}

if( $debug ) { warn( "Working directory: '$tmpDirPath'\n" ); }

# get input files
my @files;
if(!$fastaFile){
    opendir our($inputDir), $inputDirPath ||  confess "\nError: Couldn't open dir '$inputDirPath': $!\n";
    @files = readdir $inputDir;
    closedir $inputDir;
} 
else 
{
    @files=($fastaFile);
}

# check that the domain name is correct
if($domain ne "arch" && $domain ne "bact" && $domain ne "euka")
{
	confess "\nError: Unknown domain $domain\nLocTree2 requires a domain tag to run.\nPlease use:\n'arch' for Archaea\n'bact' for Bacteria\n'euka' for Eukaryota\n";
}

my $combinedFastaFile= File::Spec->catfile($tmpDirPath, "combinedFastaFile.txt");
my $combinedProfileFile= File::Spec->catfile($tmpDirPath, "combinedProfileFile.txt");
open COMBFASTAFILE, ">$combinedFastaFile" || confess "\nError: Couldn't open combined fasta file $combinedFastaFile: $!\n";
open COMBPROFILEFILE, ">$combinedProfileFile" || confess "\nError: Couldn't open combined profile file $combinedProfileFile: $!\n";

my $fileExt;
my $errorSeq="";
my $sequence;
my $fastaCounter=0;
my $profileCounter=0;
my $foundHeader=0;
my $seqId;
my $fasta;
my $isCorrectProfileFormat=0;

foreach my $fastaFileName (@files)
{
    #read fasta file
	$fileExt = ($fastaFileName =~ m/([^.]+)$/)[0];
	if(defined $fileExt || $fastaFile)
    { 
        if((($fileExt eq "fasta") || ($fileExt eq "fa") || ($fileExt eq "f")) || $fastaFile)
        {
            $foundHeader=0;
            $seqId="";
            $sequence="";
            
            if(!$fastaFile){$fasta=$inputDirPath."$fastaFileName";} else {$fasta=$fastaFile;}
            open FASTAFILE, $fasta || confess "\nError: Couldn't open fasta file $fasta: $!\n";
			while (my $faLine = <FASTAFILE>) 
			{ 
				chomp($faLine);
    				if($faLine =~  m/^>/)
    				{
	    				if(! $sequence eq ""){
                        die_usage("\nFasta file $fasta contains more than one entry.\nThis is not allowed.\nProgram will exit.\n\n");
					    }	
			    		my @spliti = split(/\s+/,substr($faLine,1));
                        $seqId = $spliti[0];
                        $fastaCounter++;
                        $foundHeader=1;
    				}
    				elsif(! $faLine eq "")
    				{
                        $faLine =~ s/\s//g;
				    	$sequence=$sequence.$faLine;
    				}
			}
			close(FASTAFILE);
           
            if($foundHeader == 0){
                confess("\nFasta file $fasta contains no opening tag '>' in the header.\nThis is not allowed.\nProgram will exit.\n\n");
            }
            if($sequence eq ""){
                confess("\nFasta file $fasta contains no amino acid sequence.\nThis is not allowed.\nProgram will exit.\n\n");
            }
            if(length($sequence)<6){
                $errorSeq=$errorSeq."# $seqId has ".length($sequence)." residues => too short. Minimum length allowed: 6 residues.\n";
                if( !$quiet ){print "# No prediction possible for $seqId. It has ".length($sequence)." residues => too short. Minimum length allowed: 6 residues.\n";}
                $seqId="";
            }
            #read profile file
			my $profile;
            if(! $seqId eq "")
            { 
                my $profileFileName = $fastaFileName;
			    $profileFileName =~ s/$fileExt/profile/g;
                if(!$blastMat){
                    $profile=$inputDirPath.$profileFileName;
			        if (! -e $profile && ! $seqId eq ""){
				        $profileFileName =~ s/profile/blastPsiMat/g;
                        $profile=$inputDirPath.$profileFileName;
				        if (! -e $profile){
					        $profileFileName =~ s/blastPsiMat/blast/g;
                            $profile=$inputDirPath.$profileFileName;
					        if (! -e $profile){
					            $profileFileName =~ s/blast/psiBlast/g;
                                $profile=$inputDirPath.$profileFileName;
						        if (!-e $profile){
							        $errorSeq=$errorSeq."# $seqId has no profile file specified.\n";
                                    if( !$quiet ){print "$seqId has no profile file specified.\n";}
							        $seqId="";
						        }
					        }
				        }
			        }
                } else {
                    $profile=$blastMat;
                }
                if(! $seqId eq "")
                {
                    $isCorrectProfileFormat=0;
			    	print COMBFASTAFILE ">" . $seqId . "\n";
    			    print COMBFASTAFILE $sequence."\n";
				    print COMBPROFILEFILE ">" . $seqId . "\n";

   				    open BLASTPSIMAT, $profile || confess "\nError: Couldn't open profile file $profile: $!\n";
    			    while(my $profLine = <BLASTPSIMAT>)
    			    {
                        if($profLine =~ m/PSI Gapped/) {
                            $isCorrectProfileFormat=1;
                            $profileCounter++;
                        }
      				    print COMBPROFILEFILE $profLine;
    			    }
    			    close(BLASTPSIMAT);
                
                    if($isCorrectProfileFormat==0){
                        confess("\nProfile file $profile is in a wrong format. For the correct format please have a look at examples.\nProgram will exit.\n\n");
                    }
                }
			}
		}
	}
}
close(COMBFASTAFILE);
close(COMBPROFILEFILE);

if($fastaCounter==0)
{
    die_usage("\nError: the directory $inputDirPath contains no fasta files.\n")
} else {
    # read in the input fasta and profile files
    if( !$quiet ){print "Printing results to ".$outputFilePath."\n";}
}

predictionsMaker($profileCounter,$tmpDirPath,$combinedFastaFile,$combinedProfileFile,$outputFilePath,$errorSeq,$domain);

#############################################
###run profkernel-workflow for predictions###
sub predictionsMaker{

    my $profileCounter=shift;
	my $tmpDirPath=shift;
	my $combinedFastaFile=shift;
	my $combinedProfileFile=shift;
	my $outputFilePath=shift;
	my $errorSeq=shift;
    my $domian=shift;
	if( $debug ) { warn( "\nRunning profkernel-workflow." ); }
    my $baseDir = glob($config->val('loctree2', 'basedir'));
    my $dataDir = glob($config->val('loctree2', 'datadir'));
    my $modelPath = File::Spec->catfile($dataDir, $domain."_model");
    my $tmpWorkflowOutFile = File::Spec->catfile($tmpDirPath, $domain."_workflow.txt");
	
    #run profkernel-workflow command
    if($profileCounter>0){
        my $profkernelworkflowCommand = "profkernel-workflow -f $combinedFastaFile -p $combinedProfileFile -m $modelPath  -o $tmpWorkflowOutFile -q";
	    if( $debug ) { warn( "Executing profkernel-workflow command:\n$profkernelworkflowCommand\n" ); }
        system($profkernelworkflowCommand) && confess "\nError running profkernel-workflow command: $!\n";
    }

    #print predictions in a temp file
    my $predOutputFile = File::Spec->catfile($tmpDirPath, "predictions.txt");
	open(PREDS, ">$predOutputFile") || confess ("\nError: Unable to open predictions file $predOutputFile: $!\n");
	print PREDS "#Localization Prediction using LocTree2\n";
	if($domain eq "euka"){
		print PREDS "#Note: chloroplast and plastid classes are valid for plant proteins only.\n"; 
		print PREDS "#Therefore, if the origin of a non-plant protein is known, please consider predictions of these classes as mitochondrial.\n";
	}
	print PREDS "#Domain: $domain\n";
	if(length($errorSeq) > 1)
	{
		print PREDS "# No predictions were possible for:\n";
        print PREDS $errorSeq;
		print PREDS "# \n";
	}

    if($profileCounter>0){
	    print PREDS "#Protein Id\tLocalization\tScore\n"; 
    	open(WFLOWOUT, "<$tmpWorkflowOutFile") || confess "Error: Unable to open weka log file $tmpWorkflowOutFile: $!\n";
        my @splitLine;
        #my $goTerm;
        my $id="";
        my $className="";
        my $prob;

	    while (my $line = <WFLOWOUT>)
	    {
            if($line !~ /^#/o)
		    {
                my ($id,$className,$prob)=split("\t",$line);
                
				    if($className =~ m/secret/o){
			            $className="secreted";
#                       $goTerm="extracellular region GO:0005576;"
				    } elsif($className =~ m/cellmem/o){
				        $className="plasma membrane";
#                       $goTerm="plasma membrane GO:0005886; integral to membrane GO:0016021;";
				    } elsif($className =~ m/inner_me/o){
				        $className="inner membrane";
#                       $goTerm="plasma membrane GO:0005886; integral to membrane GO:0016021;";
				    } elsif($className =~ m/outer_me/o){
				        $className="outer membrane";
#                       $goTerm="cell outer membrane GO:0009279; integral to membrane GO:0016021;";
				    } elsif($className =~ m/memnucl/o){
				        $className="nucleus membrane";
#                       $goTerm="nuclear membrane GO:0031965; integral to membrane GO:0016021;";
				    } elsif($className =~ m/nucleus/o){
				        $className="nucleus";
#                       $goTerm="nucleus GO:0005634";
				    } elsif($className =~ m/cytopla/o){
				        $className="cytosol";
#                       $goTerm="cytoplasm GO:0005737"; 
				    } elsif($className =~ m/memmito/o){
				        $className="mitochondria membrane";
#                       $goTerm="mitochondrial inner membrane GO:0005743; integral to membrane GO:0016021;";           
				    } elsif($className =~ m/mitochon/o){
				        $className="mitochondria";
#                       $goTerm="mitochondrion GO:0005739;";
				    } elsif($className =~ m/memchlo/o){
				        $className="chloroplast membrane";
#                       $goTerm="chloroplast thylakoid membrane GO:0009535; integral to membrane GO:0016021;";
				    } elsif($className =~ m/chloropl/o){
				        $className="chloroplast";
#                       $goTerm="chloroplast GO:0009507;";
				    } elsif($className =~ m/memgolgi/o){
				        $className="golgi apparatus membrane";
#                       $goTerm="Golgi membrane GO:0000139; integral to membrane GO:0016021;";
				    } elsif($className =~ m/golgi/o){
				        $className="golgi apparatus";
#                       $goTerm="Golgi apparatus GO:0005794;";
				    } elsif($className =~ m/memperox/o){
				        $className="peroxisome membrane";
#                       $goTerm="peroxisomal membrane GO:0005778; integral to membrane GO:0016021;";
				    } elsif($className =~ m/perox/o){
				        $className="peroxisome";
#                       $goTerm="peroxisome GO:0005777;";
				    } elsif($className eq "memer"){
				        $className="endoplasmic reticulum membrane";
#                       $goTerm="endoplasmic reticulum membrane GO:0005789; integral to membrane GO:0016021;";
				    } elsif($className eq "er"){
				        $className="endoplasmic reticulum";
#                       $goTerm="endoplasmic reticulum GO:0005783;";
				    } elsif($className =~ m/memvacu/){
				        $className="vacuole membrane";
#                       $goTerm="vacuolar membrane GO:0005774; integral to membrane GO:0016021;";
				    } elsif($className =~ m/vacuol/){
				        $className="vacuole";
#                       $goTerm="vacuole GO:0005773;";
				    } elsif($className =~ m/plastid/){
				        $className="plastid";
#                       $goTerm="plastid GO:0009536;";
				    } elsif($className =~ m/fimbrium/){
				        $className="fimbrium";
#                       $goTerm="pilus GO:0009289;";
				    } elsif($className =~ m/peripl/){
				        $className="periplasm";
#                       $goTerm="periplasmic space GO:0042597;";
				    } else {
				        confess ("\nError: Unknown localization $className in $tmpWorkflowOutFile. Please contact the developers at localization\@rostlab.org\n");
				    }
				    my $relIndex = ((100*$prob)-20)*10/8;
				    my $roundedRI = int($relIndex + 0.5);
                    print PREDS $id . "\t" . $className . "\t" . $roundedRI . "\n";
		    }	
	    }
	    close(WFLOWOUT);
    }        
	close(PREDS);
	
	move($predOutputFile,$outputFilePath) || confess "\nError: Copy failed: $!: $predOutputFile => $outputFilePath\n";
}

__END__

=pod

=head1 NAME

loctree2 - protein sub-cellular localization prediction for all domains of life

=head1 SYNOPSIS

loctree2 [OPTION]

=head1 DESCRIPTION

LocTree2 is a method to predict the sub-cellular localization of transmembrane and water-soluble globular proteins in all domains of life.

LocTree2 combines three different systems of classification trees to predict 3 localization classes in Archaea, 6 classes in Bacteria, and 18 classes in Eukaryota.

Amongst the novel aspects of LocTree2 are: 

=over

 * incorporation of no other information than evolutionary profiles 
 * very accurate in distinction: membrane/water-soluble globular proteins 
 * high robustness against sequencing errors 
 * top performance even for protein fragments
 * high prediction speed

=back

Large - about 3.5G in total - data files necessary for the operation of loctree2 are downloaded automatically on the first use of the program.  The download is restartable.
You can also make an explicit call to F<E<lt>basedirE<gt>/loctree2data> (by default F</usr/share/loctree2/loctree2data>) to download the data files.  In case the data directory (by default F</usr/share/loctree2-data>) is not writable and you are not root, the operation is reattempted with sudo(8).

=head2 Input files

LocTree2 requires two files for a protein sequence to be predicted:

 1. fasta file [.fasta|.fa|.f]
 2. evolutionary profile file [.profile|.blast|.psiBlast|.blastPsiMat]

We create evolutionary profiles by running PSI-BLAST against an 80% non-redundant database combining SWISS-PROT, TrEMBL (http://www.uniprot.org/) and PDB (http://www.pdb.org) using the command:

blastpgp -F F -a 1 -j 3 -b 3000 -e 1 -h 1e-3 -d /path_to_big80_database/big_80 -i /path/example.fasta -o /path/example.blastPsiOutTmp -C /path/example.chk -Q /path/example.profile

For the contents of the profile files please have a look at examples.

=head2 Output format

Protein Id  Localization    Score

<protein_id>    <localization_class>    [0-100]

See example outputs in F</usr/share/doc/loctree2/examples>

=head1 REFERENCES

Goldberg, T., Hamp, T., and Rost, B. (2012). LocTree2 predicts localization for all domains of life. Bioinformatics 2012 28: i458-i456

=head1 OPTIONS

=head2 Mandatory

=over

=item -i, --indir

Input directory with one fasta and one evolutionary profile file for each sequence to be predicted. A fasta file must contain exactly ONE protein sequence. Corresponding fasta and profile files must have the same prefix (i.e. if there is a file "example.fasta", there must also be a file "example.profile). Or use --fasta and --blastmat.

=item -f, --fasta

File containing exactly one fasta input sequence. This parameter must be used in combination with B<--blastmat>.

=item -b, --blastmat

File containing exactly one evolutionary profile matrix in a format like that of blastpgp(1) B<-Q> ('Output File for PSI-BLAST Matrix in ASCII') option. This parameter must be used in combination with B<--fasta>.

=item -r, --resfile
    
Output result file. Note, protein name provided in the fasta header will be truncated at the first whitespace character for output.

=item -d, --domain
     
The domain of the organism of the protein sequences to be predicted
 Options:
 'arch' for Archaea
 'bact' for Bacteria
 'euka' for Eukaryota

=back

=head2 Optional

=over

=item -p, --printdebug
     
Print debugging messages

=item -q, --quiet

Silence progress messages

=item -t, --tmpdir
           
Working directory. Intermediate files will be saved here. If not given, a temporary directory is used. The temporary directory is automatically removed at the end of a run when debugging is off

=back

=head1 EXAMPLES

C<loctree2 --in /usr/share/doc/loctree2/examples/arch/ --resfile ./arch_output.lc2 --domain arch>

C<loctree2 -i /usr/share/doc/loctree2/examples/bact/ -r ./bact_output.lc2 -d bact>

C<loctree2 -i /usr/share/doc/loctree2/examples/euka/ -r ./euka_output.lc2 -d euka>

or 

C<loctree2 --fasta /usr/share/doc/loctree2/examples/arch/arch_example.fa --blastmat /usr/share/doc/loctree2/examples/arch/arch_example.profile --resfile ./arch_output.lc2 --domain arch>

C<loctree2 -f /usr/share/doc/loctree2/examples/arch/arch_example.fa -b /usr/share/doc/loctree2/examples/arch/arch_example.profile -r ./arch_output.lc2 -d arch>

=head1 BUGS

Please report bugs at localization@rostlab.org

=head1 ENVIRONMENT

=over

=item LOCTREE2CONF

Location of loctree2rc configuration file to use, overriding other configuration files

=back

=head1 FILES

=over

=item F</usr/share/loctree2/loctree2rc.default>

Default configuration file. See this file for a description of the parameters

=item F</etc/loctree2rc>

System configuration file overriding values in F</usr/share/loctree2/loctree2rc.default>

=item F<~/.loctree2rc>

User configuration file overriding values in F</etc/loctree2rc>

=item F<$LOCTREE2CONF>

If this environment variable is set F<~/.loctree2rc> is disregarded and the value of the variable is read for configuration options overriding F</etc/loctree2rc>

=back

=head1 AUTHOR

Tatyana Goldberg, Tobias Hamp, Burkhard Rost

=head1 COPYRIGHT AND LICENSE

(C) Copyright 2012, Tatyana Goldberg, Technical University of Munich, Germany

This program is licensed under the GNU GENERAL PUBLIC LICENSE.

=head1 SEE ALSO

blastpgp(1)

=cut

# vim:ai:ts=4:et:
